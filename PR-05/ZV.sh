#!/bin/bash

# Инициализация переменных для хранения имен файлов
input_file=""
output_file=""
log_file=""

# 1. ОБРАБОТКА ПАРАМЕТРОВ И КЛЮЧЕЙ
# Проверяем, переданы ли вообще аргументы
if [ $# -eq 0 ]; then
    echo "Ошибка: Не указаны параметры. Используйте ключи -i, -o, -e."
    exit 1
fi

while [ -n "$1" ]
do
    case "$1" in
        -i)
            # Проверяем, есть ли следующее значение и не является ли оно другим ключом
            if [[ -n "$2" && "$2" != -* ]]; then
                input_file="$2"
                shift
            else
                read -p "Введите имя исходного файла (ввод): " input_file
            fi
        ;;
        -o)
            if [[ -n "$2" && "$2" != -* ]]; then
                output_file="$2"
                shift
            else
                read -p "Введите имя выходного файла (результат): " output_file
            fi
        ;;
        -e)
            if [[ -n "$2" && "$2" != -* ]]; then
                log_file="$2"
                shift
            else
                read -p "Введите имя файла для лога пустых строк (ошибки): " log_file
            fi
        ;;
        *)
            echo "Ошибка: Неверный ключ $1"
            exit 1
        ;;
    esac
    shift
done

# 2. ПРОВЕРКА ВВОДНЫХ ДАННЫХ
# Проверяем, заполнены ли все переменные (указаны ли все ключи)
if [[ -z "$input_file" || -z "$output_file" || -z "$log_file" ]]; then
    echo "Ошибка: Вы указали не все ключи (-i, -o, -e)."
    exit 1
fi

# Проверка существования исходного файла
if [ ! -f "$input_file" ]; then
    echo "Ошибка: Исходный файл '$input_file' не существует."
    exit 1
fi

# 3. НАСТРОЙКА ПОТОКОВ ЧЕРЕЗ EXEC
# Сохраняем стандартные дескрипторы для возможности возврата (опционально)
exec 6<&0 # Сохраняем STDIN
exec 7>&1 # Сохраняем STDOUT
exec 8>&2 # Сохраняем STDERR

# Перенаправляем потоки на файлы
exec 0< "$input_file"    # Теперь read будет читать из файла
exec 1> "$output_file"   # Теперь echo будет писать в выходной файл
exec 2> "$log_file"      # Теперь вывод в дескриптор 2 пойдет в лог

# 4. ОБРАБОТКА ФАЙЛА
line_num=1

# Читаем файл построчно из STDIN (который теперь файл)
# IFS= предотвращает обрезку пробелов в начале и конце строк
# -r запрещает интерпретацию обратных слэшей
while IFS= read -r line || [[ -n "$line" ]]
do
    # Проверка: является ли строка пустой
    if [ -z "$line" ]; then
        # Если пустая, пишем её номер в STDERR (в лог-файл)
        echo "Найдена пустая строка: номер $line_num" >&2
    else
        # Если не пустая, пишем содержимое в STDOUT (в выходной файл)
        echo "$line"
    fi
    (( line_num++ ))
done

# 5. ВОССТАНОВЛЕНИЕ ПОТОКОВ
exec 0<&6 6<&-
exec 1>&7 7>&-
exec 2>&8 8>&-

# Вывод итогового сообщения в терминал (поскольку потоки восстановлены)
echo "---------------------------------------"
echo "Обработка завершена успешно."
echo "Входной файл: $input_file"
echo "Выходной файл: $output_file"
echo "Лог пустых строк: $log_file"